- minus sign is just listing an item
x- means that item is done
-------------------------------------------

x- create db
x- create mock schema
x- create mock get messages table / data / proc
x- create node.js app to get messages from mysql db depending on run type
    x - update table to say batch is complete (stored proc)
x- flesh out db schema
x- flesh out logging tables
- plan better solution for storing logs
    http://brian.moonspot.net/logging-with-mysql

x- need logging tables
x- need log offloader script
    x- log tables can be dumped out after x days to a .sql file, and then rotate the table
    x- simply use the mysqldump command for relevant tables

x- TODO: figure role company restriction (or allow list) via role table

x- proc moves data to history
    x--removes entries from log tables

x- table of contact methods
x- table of contact status / description

x- figure out a shard method or clustering
    x- and how it works into the db design
    Decision: sharding from the get go might be unnecessary effort in early stages.. I just want to make the db design solid.
    x- Before really considering clustering/replication tests need to be made...tuning the db, data offloading from queue tables, log tables, etc...
    x- Read replication is the next easy step to consider.. just have the application deci
    x- Consider ProxySQL

    - The best way might be to make sure the db is designed for in[serts and selects rather than updates
       https://medium.com/@benmorel/high-speed-inserts-with-mysql-9d3dcd76f723
       Then also make sure db inserts are tuned

Maybe integrate a real queueing system like RabbitMQ
    https://www.engineyard.com/blog/5-subtle-ways-youre-using-mysql-as-a-queue-and-why-itll-bite-you
    instead of making the db into one.. but what about

x- review current schema, compare against MVP outline

x- will need a status update xref table for email, sms, phone and other

x-need to add offloader for messages_status_updates

x-last consideration:
    x-I split messages and messages_contact_status tables.. now we need to maintain history for both tables and rotate both?
    --yes, split history offloading too

- flesh out ui supported features/actions
- plan api gateway / api endpoints for supporting the platform
- write with swagger

- review stored procs already created, may need corrections based on changes to the db design
- stored procs for maintenance fleshed out
- stored procs fleshed out: temp tables, where clauses
- write stored procs


- plan indices
- write indices
- create tests for failures ..?
- create tests

----------------------------------------------------
consider:
track user interactions with the system -- users most likely to respond and respond postively to surveys and reviews
